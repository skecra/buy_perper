'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var sha2 = require('multiformats/hashes/sha2');
var murmur3 = require('@multiformats/murmur3');
var blake2b = require('@multiformats/blake2/blake2b');
var blake2s = require('@multiformats/blake2/blake2s');
var sha3 = require('@multiformats/sha3');
var equals = require('uint8arrays/equals');

const hashMap = new Map([
  sha2.sha256,
  sha2.sha512,
  murmur3.murmur3128,
  murmur3.murmur332,
  blake2b.blake2b256,
  blake2s.blake2s256,
  sha3.sha3224,
  sha3.sha3256,
  sha3.sha3384,
  sha3.sha3512,
  sha3.shake128,
  sha3.shake256,
  sha3.keccak224,
  sha3.keccak256,
  sha3.keccak384,
  sha3.keccak512
].map(hash => [
  hash.code,
  hash
]));
class UnsupportedHashError extends Error {
  constructor(code) {
    super(`multihash code ${ code } is not supported`);
  }
}
class HashMismatchError extends Error {
  constructor() {
    super('CID hash does not match bytes');
  }
}
function validateBlock(block) {
  const hasher = hashMap.get(block.cid.multihash.code);
  if (!hasher) {
    throw new UnsupportedHashError(block.cid.multihash.code);
  }
  const result = hasher.digest(block.bytes);
  const compareDigests = h => {
    if (!equals.equals(h.digest, block.cid.multihash.digest)) {
      throw new HashMismatchError();
    }
  };
  if (result instanceof Promise) {
    return result.then(compareDigests);
  }
  compareDigests(result);
}

exports.HashMismatchError = HashMismatchError;
exports.UnsupportedHashError = UnsupportedHashError;
exports.hashMap = hashMap;
exports.validateBlock = validateBlock;
